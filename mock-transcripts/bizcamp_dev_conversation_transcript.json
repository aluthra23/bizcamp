[
    {
        "text": "Okay, let's figure out what stack we want to use. Should we just default to what we\u2019re all comfortable with?",
        "start_time": 0,
        "end_time": 10
    },
    {
        "text": "I mean, Next.js is a no-brainer for frontend\u2014gives us full-stack capabilities and we can SSR if we need to.",
        "start_time": 10,
        "end_time": 20
    },
    {
        "text": "Yeah and it plays super nicely with React, so we can get the component-based architecture right off the bat.",
        "start_time": 20,
        "end_time": 30
    },
    {
        "text": "For the backend though, I\u2019m leaning toward FastAPI. It\u2019s async by default and super quick to get endpoints up.",
        "start_time": 30,
        "end_time": 40
    },
    {
        "text": "What about the database? Should we go with MongoDB since it's easy to handle nested meeting data?",
        "start_time": 40,
        "end_time": 50
    },
    {
        "text": "MongoDB works. The document model will let us store user, department, team, and meeting info really cleanly.",
        "start_time": 50,
        "end_time": 60
    },
    {
        "text": "Wait, should we also use Node.js for certain scripts or maybe routing to FastAPI?",
        "start_time": 60,
        "end_time": 70
    },
    {
        "text": "Actually yeah\u2014maybe use Node as a lightweight proxy and stick with Python for the heavy AI stuff.",
        "start_time": 70,
        "end_time": 80
    },
    {
        "text": "Now that stack is solid: Next.js, React, FastAPI backend, MongoDB database, Node for middleware. Agreed?",
        "start_time": 80,
        "end_time": 90
    },
    {
        "text": "Yup, agreed. Now let\u2019s start putting structure to this on the Google Doc.",
        "start_time": 90,
        "end_time": 100
    },
    {
        "text": "We need a login and signup page first\u2014basic auth, and route the user to their homepage after logging in.",
        "start_time": 100,
        "end_time": 110
    },
    {
        "text": "On the home page, users should see their departments as cards. Click one and it reveals teams inside.",
        "start_time": 110,
        "end_time": 120
    },
    {
        "text": "When you click a team, that opens a calendar with all their meetings. We\u2019ll use FullCalendar or React Big Calendar.",
        "start_time": 120,
        "end_time": 130
    },
    {
        "text": "Clicking a meeting opens a dashboard\u2014PDF upload, start recording, and live transcription options.",
        "start_time": 130,
        "end_time": 140
    },
    {
        "text": "Then we can have a nav bar where users can jump to Summaries or Concept Graphs from that meeting.",
        "start_time": 140,
        "end_time": 150
    },
    {
        "text": "Okay for summaries, we\u2019ll store them under a separate MongoDB collection linked to the meeting ID.",
        "start_time": 150,
        "end_time": 160
    },
    {
        "text": "What about Qdrant? That\u2019s our vector DB right? We'll use it for storing transcript embeddings.",
        "start_time": 160,
        "end_time": 170
    },
    {
        "text": "Yup! After transcription, we chunk the text, embed with LangChain, and push into Qdrant.",
        "start_time": 170,
        "end_time": 180
    },
    {
        "text": "We\u2019ll set up REST endpoints: /upload-pdf, /start-transcription, /query, and maybe /add-summary.",
        "start_time": 180,
        "end_time": 190
    },
    {
        "text": "Yeah and then we emit transcript data back to the frontend via WebSockets or SSE for live updates.",
        "start_time": 190,
        "end_time": 200
    },
    {
        "text": "Let\u2019s make the chatbot interface feel like Slack or ChatGPT. Just super smooth interaction with meeting data.",
        "start_time": 200,
        "end_time": 210
    },
    {
        "text": "We can give it the transcript and use RetrievalQA from LangChain to let it answer questions intelligently.",
        "start_time": 210,
        "end_time": 220
    },
    {
        "text": "For the concept graph, we fetch all transcript data from Qdrant and pass it through Gemini with a custom prompt.",
        "start_time": 220,
        "end_time": 230
    },
    {
        "text": "The prompt should extract 10-15 concepts and link them as nodes and edges with timestamps and strength values.",
        "start_time": 230,
        "end_time": 240
    },
    {
        "text": "Let\u2019s make the graph interactive\u2014users can move nodes, inspect relationships, and click to jump to transcript points.",
        "start_time": 240,
        "end_time": 250
    },
    {
        "text": "And we should support semantic diffing between two meetings\u2014highlight new ideas, reopened topics, and changes.",
        "start_time": 250,
        "end_time": 260
    },
    {
        "text": "Also, users should be able to pick summarization formats: bullet points, slide decks, risk tables\u2014you name it.",
        "start_time": 260,
        "end_time": 270
    },
    {
        "text": "We'll make it modular\u2014each meeting can evolve its own knowledge graph, sub-agents, and summarized threads.",
        "start_time": 270,
        "end_time": 280
    },
    {
        "text": "Alright, now let\u2019s set up the project. I\u2019ll scaffold the Next.js frontend.",
        "start_time": 280,
        "end_time": 290
    },
    {
        "text": "And I\u2019ll spin up the FastAPI backend with all the endpoints defined and ready for testing.",
        "start_time": 290,
        "end_time": 300
    },
    {
        "text": "I'll get MongoDB set up and structure the collections as discussed: Users, Companies, Departments, Teams, Meetings, Summaries.",
        "start_time": 300,
        "end_time": 310
    }
]